import { parseTranslation, translate as _translate } from './utils';
/**
 * Load translations for `$localize`.
 *
 * The given `translations` are processed and added to a lookup based on their `MessageId`.
 * A new translation will overwrite a previous translation if it has the same `MessageId`.
 *
 * * If a message is generated by the Angular compiler from an `i18n` marker in a template, the
 *   `MessageId` is passed through to the `$localize` call as a custom `MessageId`. The `MessageId`
 *   will match what is extracted into translation files.
 *
 * * If the translation is from a call to `$localize` in application code, and no custom `MessageId`
 *   is provided, then the `MessageId` can be generated by passing the tagged string message-parts
 *   to the `parseMessage()` function (not currently public API).
 *
 * @publicApi
 *
 */
export function loadTranslations(translations) {
    // Ensure the translate function exists
    if (!$localize.translate) {
        $localize.translate = translate;
    }
    if (!$localize.TRANSLATIONS) {
        $localize.TRANSLATIONS = {};
    }
    Object.keys(translations).forEach(function (key) {
        $localize.TRANSLATIONS[key] = parseTranslation(translations[key]);
    });
}
/**
 * Remove all translations for `$localize`.
 *
 * @publicApi
 */
export function clearTranslations() {
    $localize.translate = undefined;
    $localize.TRANSLATIONS = {};
}
/**
 * Translate the text of the given message, using the loaded translations.
 *
 * This function may reorder (or remove) substitutions as indicated in the matching translation.
 */
export function translate(messageParts, substitutions) {
    try {
        return _translate($localize.TRANSLATIONS, messageParts, substitutions);
    }
    catch (e) {
        console.warn(e.message);
        return [messageParts, substitutions];
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhbnNsYXRlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvbG9jYWxpemUvc3JjL3RyYW5zbGF0ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFRQSxPQUFPLEVBQStCLGdCQUFnQixFQUFpQixTQUFTLElBQUksVUFBVSxFQUFDLE1BQU0sU0FBUyxDQUFDO0FBVS9HOzs7Ozs7Ozs7Ozs7Ozs7O0dBZ0JHO0FBQ0gsTUFBTSxVQUFVLGdCQUFnQixDQUFDLFlBQThDO0lBQzdFLHVDQUF1QztJQUN2QyxJQUFJLENBQUMsU0FBUyxDQUFDLFNBQVMsRUFBRTtRQUN4QixTQUFTLENBQUMsU0FBUyxHQUFHLFNBQVMsQ0FBQztLQUNqQztJQUNELElBQUksQ0FBQyxTQUFTLENBQUMsWUFBWSxFQUFFO1FBQzNCLFNBQVMsQ0FBQyxZQUFZLEdBQUcsRUFBRSxDQUFDO0tBQzdCO0lBQ0QsTUFBTSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQyxPQUFPLENBQUMsVUFBQSxHQUFHO1FBQ25DLFNBQVMsQ0FBQyxZQUFZLENBQUMsR0FBRyxDQUFDLEdBQUcsZ0JBQWdCLENBQUMsWUFBWSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7SUFDcEUsQ0FBQyxDQUFDLENBQUM7QUFDTCxDQUFDO0FBRUQ7Ozs7R0FJRztBQUNILE1BQU0sVUFBVSxpQkFBaUI7SUFDL0IsU0FBUyxDQUFDLFNBQVMsR0FBRyxTQUFTLENBQUM7SUFDaEMsU0FBUyxDQUFDLFlBQVksR0FBRyxFQUFFLENBQUM7QUFDOUIsQ0FBQztBQUVEOzs7O0dBSUc7QUFDSCxNQUFNLFVBQVUsU0FBUyxDQUFDLFlBQWtDLEVBQUUsYUFBNkI7SUFFekYsSUFBSTtRQUNGLE9BQU8sVUFBVSxDQUFDLFNBQVMsQ0FBQyxZQUFZLEVBQUUsWUFBWSxFQUFFLGFBQWEsQ0FBQyxDQUFDO0tBQ3hFO0lBQUMsT0FBTyxDQUFDLEVBQUU7UUFDVixPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUN4QixPQUFPLENBQUMsWUFBWSxFQUFFLGFBQWEsQ0FBQyxDQUFDO0tBQ3RDO0FBQ0gsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbmltcG9ydCB7TG9jYWxpemVGbn0gZnJvbSAnLi9sb2NhbGl6ZSc7XG5pbXBvcnQge01lc3NhZ2VJZCwgUGFyc2VkVHJhbnNsYXRpb24sIHBhcnNlVHJhbnNsYXRpb24sIFRhcmdldE1lc3NhZ2UsIHRyYW5zbGF0ZSBhcyBfdHJhbnNsYXRlfSBmcm9tICcuL3V0aWxzJztcblxuLyoqXG4gKiBXZSBhdWdtZW50IHRoZSBgJGxvY2FsaXplYCBvYmplY3QgdG8gYWxzbyBzdG9yZSB0aGUgdHJhbnNsYXRpb25zLlxuICpcbiAqIE5vdGUgdGhhdCBiZWNhdXNlIHRoZSBUUkFOU0xBVElPTlMgYXJlIGF0dGFjaGVkIHRvIGEgZ2xvYmFsIG9iamVjdCwgdGhleSB3aWxsIGJlIHNoYXJlZCBiZXR3ZWVuXG4gKiBhbGwgYXBwbGljYXRpb25zIHRoYXQgYXJlIHJ1bm5pbmcgaW4gYSBzaW5nbGUgcGFnZSBvZiB0aGUgYnJvd3Nlci5cbiAqL1xuZGVjbGFyZSBjb25zdCAkbG9jYWxpemU6IExvY2FsaXplRm4me1RSQU5TTEFUSU9OUzogUmVjb3JkPE1lc3NhZ2VJZCwgUGFyc2VkVHJhbnNsYXRpb24+fTtcblxuLyoqXG4gKiBMb2FkIHRyYW5zbGF0aW9ucyBmb3IgYCRsb2NhbGl6ZWAuXG4gKlxuICogVGhlIGdpdmVuIGB0cmFuc2xhdGlvbnNgIGFyZSBwcm9jZXNzZWQgYW5kIGFkZGVkIHRvIGEgbG9va3VwIGJhc2VkIG9uIHRoZWlyIGBNZXNzYWdlSWRgLlxuICogQSBuZXcgdHJhbnNsYXRpb24gd2lsbCBvdmVyd3JpdGUgYSBwcmV2aW91cyB0cmFuc2xhdGlvbiBpZiBpdCBoYXMgdGhlIHNhbWUgYE1lc3NhZ2VJZGAuXG4gKlxuICogKiBJZiBhIG1lc3NhZ2UgaXMgZ2VuZXJhdGVkIGJ5IHRoZSBBbmd1bGFyIGNvbXBpbGVyIGZyb20gYW4gYGkxOG5gIG1hcmtlciBpbiBhIHRlbXBsYXRlLCB0aGVcbiAqICAgYE1lc3NhZ2VJZGAgaXMgcGFzc2VkIHRocm91Z2ggdG8gdGhlIGAkbG9jYWxpemVgIGNhbGwgYXMgYSBjdXN0b20gYE1lc3NhZ2VJZGAuIFRoZSBgTWVzc2FnZUlkYFxuICogICB3aWxsIG1hdGNoIHdoYXQgaXMgZXh0cmFjdGVkIGludG8gdHJhbnNsYXRpb24gZmlsZXMuXG4gKlxuICogKiBJZiB0aGUgdHJhbnNsYXRpb24gaXMgZnJvbSBhIGNhbGwgdG8gYCRsb2NhbGl6ZWAgaW4gYXBwbGljYXRpb24gY29kZSwgYW5kIG5vIGN1c3RvbSBgTWVzc2FnZUlkYFxuICogICBpcyBwcm92aWRlZCwgdGhlbiB0aGUgYE1lc3NhZ2VJZGAgY2FuIGJlIGdlbmVyYXRlZCBieSBwYXNzaW5nIHRoZSB0YWdnZWQgc3RyaW5nIG1lc3NhZ2UtcGFydHNcbiAqICAgdG8gdGhlIGBwYXJzZU1lc3NhZ2UoKWAgZnVuY3Rpb24gKG5vdCBjdXJyZW50bHkgcHVibGljIEFQSSkuXG4gKlxuICogQHB1YmxpY0FwaVxuICpcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxvYWRUcmFuc2xhdGlvbnModHJhbnNsYXRpb25zOiBSZWNvcmQ8TWVzc2FnZUlkLCBUYXJnZXRNZXNzYWdlPikge1xuICAvLyBFbnN1cmUgdGhlIHRyYW5zbGF0ZSBmdW5jdGlvbiBleGlzdHNcbiAgaWYgKCEkbG9jYWxpemUudHJhbnNsYXRlKSB7XG4gICAgJGxvY2FsaXplLnRyYW5zbGF0ZSA9IHRyYW5zbGF0ZTtcbiAgfVxuICBpZiAoISRsb2NhbGl6ZS5UUkFOU0xBVElPTlMpIHtcbiAgICAkbG9jYWxpemUuVFJBTlNMQVRJT05TID0ge307XG4gIH1cbiAgT2JqZWN0LmtleXModHJhbnNsYXRpb25zKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgJGxvY2FsaXplLlRSQU5TTEFUSU9OU1trZXldID0gcGFyc2VUcmFuc2xhdGlvbih0cmFuc2xhdGlvbnNba2V5XSk7XG4gIH0pO1xufVxuXG4vKipcbiAqIFJlbW92ZSBhbGwgdHJhbnNsYXRpb25zIGZvciBgJGxvY2FsaXplYC5cbiAqXG4gKiBAcHVibGljQXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbGVhclRyYW5zbGF0aW9ucygpIHtcbiAgJGxvY2FsaXplLnRyYW5zbGF0ZSA9IHVuZGVmaW5lZDtcbiAgJGxvY2FsaXplLlRSQU5TTEFUSU9OUyA9IHt9O1xufVxuXG4vKipcbiAqIFRyYW5zbGF0ZSB0aGUgdGV4dCBvZiB0aGUgZ2l2ZW4gbWVzc2FnZSwgdXNpbmcgdGhlIGxvYWRlZCB0cmFuc2xhdGlvbnMuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBtYXkgcmVvcmRlciAob3IgcmVtb3ZlKSBzdWJzdGl0dXRpb25zIGFzIGluZGljYXRlZCBpbiB0aGUgbWF0Y2hpbmcgdHJhbnNsYXRpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2xhdGUobWVzc2FnZVBhcnRzOiBUZW1wbGF0ZVN0cmluZ3NBcnJheSwgc3Vic3RpdHV0aW9uczogcmVhZG9ubHkgYW55W10pOlxuICAgIFtUZW1wbGF0ZVN0cmluZ3NBcnJheSwgcmVhZG9ubHkgYW55W11dIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gX3RyYW5zbGF0ZSgkbG9jYWxpemUuVFJBTlNMQVRJT05TLCBtZXNzYWdlUGFydHMsIHN1YnN0aXR1dGlvbnMpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgY29uc29sZS53YXJuKGUubWVzc2FnZSk7XG4gICAgcmV0dXJuIFttZXNzYWdlUGFydHMsIHN1YnN0aXR1dGlvbnNdO1xuICB9XG59XG4iXX0=